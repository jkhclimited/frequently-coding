Tuples, Lists, Aliasing, Mutability, Cloning
- Introducing new compound data Types

Tuples
- Ordered sequence of elems, can mix elem types 
- Can't change elem vals, immutable (non changeable)
- Represented with paranthesis 
- e.g.
    te = () 
    t = (2, "mit", 3)
    t[0] -> Evals to 2
    (2, "mit", 3) + (5, 6) -> Evals to (2, "mit", 3, 5, 6)
    t[1:2] -> slice tuple, evals to ("mit",) (extra comma means a tuple with 1 elem)
    t[1:3] -> slice tuple, evals to ("mit", 3)
    len(t) -> evals to 3
    t[1] = 4 -> error, cannot modify object 
- Can be used to swap variable values conveniently
    (x, y) = (y, x)
- Used to return more than 1 val from a function
    def quotient_and_remainder(x, y):
        q = x // y (this is integer division)
        r = x % y 
        return (q, r)
    (quot, rem) = quotient_and_remainder(4,5)

Manipulating Tuples 
- Can iterate over tuples 
def get_data(aTuple):
    nums = ()
    words = ()
    for t in aTuple:
        nums = nums + (t[0],)
        if t[1] not in words:
            words = words + (t[1],)
    min_n = min(nums)
    max_n = max(nums)
    unique_words = len(words)
    return (min_n, max_n, unique_words)

Lists 
- Ordered sequence of info
- Lists denoted by square brackets
- List contains elems 
    - Usually homogeneous (e.g. all ints)
    - Can contain mixed types (uncommon)
- List elems can eb changed so a list is mutable 

Indices and Ordering 
    a_list = [] (empty list)
    L = [2, 'a', 4, [1,2]]
    len(L) -> evals to 4

Changing Elems 
- lists are mutable
- can just assign an eleme at an index 
    L = [2, 1, 3]
    L[1] = 5
- L is now [2, 5, 3], this is still the same obj L 

Iterating Over a List 
- compute sum of elems in list 
- look for common patterns, iterate over list elems 
- e.g.
    total = 0
    for i in range(len(L)):
        total += L[i]
    print total
- list elems are indexed 0 to len(L)-1

Operations on Lists 
- add elems to the end of the list with L.append(element)
- alternatively concatenation + operator to give a new list.
- e.g.
    L1 = [2,1,3]
    L2 = [4,5,6]
    L3 = L1 + L2 -> L3 is [2,1,3,4,5,6]
- mutate list with L.extend(some_list)
- e.g. 
    L1.extend([0,6]) -> L1 mutates to [2,1,3,0,6]
- remove elems at a specific index with del(L[index])
- remove elems at end of list with L.pop(), which returns the removed elem
- remove specific elem with L.remove(element)
    - looks for the elem and removes it
    - if elem occurs multiple times, removes first occurance
    - if elem not in list, gives error

Converting Lists to Strings and Back 
- convert string to list with: list(s), returns a list with every char from s as an elem in L
- can use s.split() to split a string on a char param 
- use ''.join(L) to turn a list of chars into a str 
- e.g.
    s = "I<3 cs" -> s is a string 
    list(s)             -> returns ['I', '<', '3', ' ', 'c', 's']
    s.split('<')        -> returns ['I', '3 cs']
    L = ['a','b','c']   -> L is a list 
    ''.join(L)          -> returns "abc" 
    '_'.join(L)         -> returns "a_b_c"

Other List Ops
- sort() and sorted()
- reverse()
- e.g.
    L = [9,6,0,3]
    sorted(L)   -> returns sorted list, doesn't mutate L 
    L.sort()    -> mutates L = [0,3,6,9]
    L.reverse() -> mutates L = [9,6,3,0]

Aliases
- hot is an alias for warm - changing one changes the other too
- append() has a side effect this way!
- e.g.
    warm = ['red', 'yellow', 'orange']
    hot = warm
    hot.append('pink')
    print(hot)
    print(warm)
    - These will show the same output, see example code.

Cloning 
- instead of using an alias, you can use a clone 
- create a new list and copy every elem using e.g.
    chill = cool[:]

Sorting Lists 
- list.sort() mutates the list, doesn't return anything. 
- doing sorted() works though
    listSorted = sorted(list)

Mutation and Iteration 
- don't mutate lists while you iterate otherwise there's issues
- proper code ex:
    def remove_dups(L1, L2):
        L1_copy = L1[:]
        for e in L1_copy:
            if e in L2:
                L1.remove(e)
    L1 = [1, 2, 3, 4]
    L2 = [1, 2, 5, 6]